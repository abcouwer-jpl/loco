/***********************************************************************
 * Copyright 2003, 2020 by the California Institute of Technology
 * ALL RIGHTS RESERVED. United States Government Sponsorship acknowledged.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @file        loco_compress.c
 * @date        2020-06-15
 * @author      Matthew Klimesh, Aaron Kiely, Neil Abcouwer
 * @brief       Function definitions for LOCO compression
 *
 * This software is based on the LOCO-I algorithm which is
 *   described in:
 *
 *   Marcelo J. Weinberger, Gadiel Seroussi and Guillermo Sapiro,
 *     "LOCO-I: A Low Complexity, Context-Based, Lossless Image
 *     Compression Algorithm", in Proc. Data Compression Conference
 *     (DCC '96), pp. 140-149, 1996.
 *
 * This implementation originates with Matt Klimesh and Aaron Kiely's
 * implementation for MER, and was modified by Neil Abcouwer.
 *
 * This implementation lacks the run length encoding ("embedded
 * alphabet extension") of LOCO-I.  There are other differences as well.
 *
 */

#include <loco/loco_pub.h>
#include <loco/loco_conf_private.h>
#include <loco/loco_private.h>

/*
  WRITE_BIT(bit) macro
  Formerly used for all writing of bits in the encoded segments, now only used
  for some.

  The braces around this macro make semicolons after calls to WRITE_BIT() redundant,
  but these extra semicolons don't cause any trouble.
*/
#define WRITE_BIT(bit) \
{ \
    state->out_word |= (bit)<<(state->bit_count); \
    --state->bit_count; \
    if (state->bit_count == -1) { \
        state->bit_count = 8*sizeof(LocoBitstreamType)-1; \
        if (state->p_out < state->p_stop) {                 \
            *state->p_out = FIX_WORD(state->out_word, state->is_little_endian); \
            state->p_out++; \
        }                                            \
        state->out_word = 0; \
    } \
}

// Macros for performing context-determination-related table lookups
#define G_TO_CTXT_8BIT(g)  (loco_g_table_8bit[(g) & 511])
#define G_TO_CTXT_12BIT(g)  (loco_g_table_12bit[((g)>>3) & 1023])
#define GFOUR_TO_CTXT_8BIT(g)  (loco_gfour_table_8bit[(g) & 511])
#define GFOUR_TO_CTXT_12BIT(g)  (loco_gfour_table_12bit[((g)>>3) & 1023])

/* lookup tables */

LOCO_PRIVATE const U8 loco_g_table_8bit[512] =
     {   0,   0,  32,  32,  32,  64,  64,  64,  64,  64,  64,  64,
        64,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
        96,  96,  96,  96, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
       224, 224, 224, 224, 224, 224, 224, 224, 192, 192, 192, 192,
       192, 192, 192, 192, 160, 160, 160,   0};


LOCO_PRIVATE const U8 loco_gfour_table_8bit[512] =
    {0,0,0,0,0,0,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,

     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,0,0,0,0,0};


LOCO_PRIVATE const U8 loco_g_table_12bit[1024] =
       {  0,   0,  32,  32,  32,  32,  64,  64,  64,  64,  64,  64,
         64,  64,  64,  64,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,
         96,  96,  96,  96,  96,  96,  96,  96, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224,
        192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 160, 160,
        160, 160,   0,   0};


LOCO_PRIVATE const U8 loco_gfour_table_12bit[1024] =
    {0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,

     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,

     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,

     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,
     3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3, 0,0,0,0,0,0,0,0};


LOCO_PRIVATE const I16 loco_context_info_table[2048] =
    {   0,    2,    1,    3,    8,   10,   12,   14,   16,   18,
       20,   22,   24,   26,   28,   30,    1,    7,    1,    3,
        9,   15,    9,   11,   17,   23,   17,   19,   25,   31,
       25,   27,   64,   66,   68,   70,   72,   74,   76,   78,
       80,   82,   84,   86,   88,   90,   92,   94,   96,   98,
      100,  102,  104,  106,  108,  110,  112,  114,  116,  118,
      120,  122,  124,  126,  128,  130,  132,  134,  136,  138,
      140,  142,  144,  146,  148,  150,  152,  154,  156,  158,
      160,  162,  164,  166,  168,  170,  172,  174,  176,  178,
      180,  182,  184,  186,  188,  190,  192,  194,  196,  198,
      200,  202,  204,  206,  208,  210,  212,  214,  216,  218,
      220,  222,  224,  226,  228,  230,  232,  234,  236,  238,
      240,  242,  244,  246,  248,  250,  252,  254,    1,    7,
        1,    3,   41,   47,   41,   43,   49,   55,   49,   51,
       57,   63,   57,   59,    1,    7,    1,    3,    9,   15,
        9,   11,   17,   23,   17,   19,   25,   31,   25,   27,
       65,   71,   65,   67,  105,  111,  105,  107,  113,  119,
      113,  115,  121,  127,  121,  123,   65,   71,   65,   67,
       73,   79,   73,   75,   81,   87,   81,   83,   89,   95,
       89,   91,  129,  135,  129,  131,  169,  175,  169,  171,
      177,  183,  177,  179,  185,  191,  185,  187,  129,  135,
      129,  131,  137,  143,  137,  139,  145,  151,  145,  147,
      153,  159,  153,  155,  193,  199,  193,  195,  233,  239,
      233,  235,  241,  247,  241,  243,  249,  255,  249,  251,
      193,  199,  193,  195,  201,  207,  201,  203,  209,  215,
      209,  211,  217,  223,  217,  219,  512,  514,  516,  518,
      520,  522,  524,  526,  528,  530,  532,  534,  536,  538,
      540,  542,  544,  546,  548,  550,  552,  554,  556,  558,
      560,  562,  564,  566,  568,  570,  572,  574,  576,  578,
      580,  582,  584,  586,  588,  590,  592,  594,  596,  598,
      600,  602,  604,  606,  608,  610,  612,  614,  616,  618,
      620,  622,  624,  626,  628,  630,  632,  634,  636,  638,
      640,  642,  644,  646,  648,  650,  652,  654,  656,  658,
      660,  662,  664,  666,  668,  670,  672,  674,  676,  678,
      680,  682,  684,  686,  688,  690,  692,  694,  696,  698,
      700,  702,  704,  706,  708,  710,  712,  714,  716,  718,
      720,  722,  724,  726,  728,  730,  732,  734,  736,  738,
      740,  742,  744,  746,  748,  750,  752,  754,  756,  758,
      760,  762,  764,  766,  768,  770,  772,  774,  776,  778,
      780,  782,  784,  786,  788,  790,  792,  794,  796,  798,
      800,  802,  804,  806,  808,  810,  812,  814,  816,  818,
      820,  822,  824,  826,  828,  830,  832,  834,  836,  838,
      840,  842,  844,  846,  848,  850,  852,  854,  856,  858,
      860,  862,  864,  866,  868,  870,  872,  874,  876,  878,
      880,  882,  884,  886,  888,  890,  892,  894,  896,  898,
      900,  902,  904,  906,  908,  910,  912,  914,  916,  918,
      920,  922,  924,  926,  928,  930,  932,  934,  936,  938,
      940,  942,  944,  946,  948,  950,  952,  954,  956,  958,
      960,  962,  964,  966,  968,  970,  972,  974,  976,  978,
      980,  982,  984,  986,  988,  990,  992,  994,  996,  998,
     1000, 1002, 1004, 1006, 1008, 1010, 1012, 1014, 1016, 1018,
     1020, 1022, 1024, 1026, 1028, 1030, 1032, 1034, 1036, 1038,
     1040, 1042, 1044, 1046, 1048, 1050, 1052, 1054, 1056, 1058,
     1060, 1062, 1064, 1066, 1068, 1070, 1072, 1074, 1076, 1078,
     1080, 1082, 1084, 1086, 1088, 1090, 1092, 1094, 1096, 1098,
     1100, 1102, 1104, 1106, 1108, 1110, 1112, 1114, 1116, 1118,
     1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138,
     1140, 1142, 1144, 1146, 1148, 1150, 1152, 1154, 1156, 1158,
     1160, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176, 1178,
     1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196, 1198,
     1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214, 1216, 1218,
     1220, 1222, 1224, 1226, 1228, 1230, 1232, 1234, 1236, 1238,
     1240, 1242, 1244, 1246, 1248, 1250, 1252, 1254, 1256, 1258,
     1260, 1262, 1264, 1266, 1268, 1270, 1272, 1274, 1276, 1278,
     1280, 1282, 1284, 1286, 1288, 1290, 1292, 1294, 1296, 1298,
     1300, 1302, 1304, 1306, 1308, 1310, 1312, 1314, 1316, 1318,
     1320, 1322, 1324, 1326, 1328, 1330, 1332, 1334, 1336, 1338,
     1340, 1342, 1344, 1346, 1348, 1350, 1352, 1354, 1356, 1358,
     1360, 1362, 1364, 1366, 1368, 1370, 1372, 1374, 1376, 1378,
     1380, 1382, 1384, 1386, 1388, 1390, 1392, 1394, 1396, 1398,
     1400, 1402, 1404, 1406, 1408, 1410, 1412, 1414, 1416, 1418,
     1420, 1422, 1424, 1426, 1428, 1430, 1432, 1434, 1436, 1438,
     1440, 1442, 1444, 1446, 1448, 1450, 1452, 1454, 1456, 1458,
     1460, 1462, 1464, 1466, 1468, 1470, 1472, 1474, 1476, 1478,
     1480, 1482, 1484, 1486, 1488, 1490, 1492, 1494, 1496, 1498,
     1500, 1502, 1504, 1506, 1508, 1510, 1512, 1514, 1516, 1518,
     1520, 1522, 1524, 1526, 1528, 1530, 1532, 1534, 1536, 1538,
     1540, 1542, 1544, 1546, 1548, 1550, 1552, 1554, 1556, 1558,
     1560, 1562, 1564, 1566, 1568, 1570, 1572, 1574, 1576, 1578,
     1580, 1582, 1584, 1586, 1588, 1590, 1592, 1594, 1596, 1598,
     1600, 1602, 1604, 1606, 1608, 1610, 1612, 1614, 1616, 1618,
     1620, 1622, 1624, 1626, 1628, 1630, 1632, 1634, 1636, 1638,
     1640, 1642, 1644, 1646, 1648, 1650, 1652, 1654, 1656, 1658,
     1660, 1662, 1664, 1666, 1668, 1670, 1672, 1674, 1676, 1678,
     1680, 1682, 1684, 1686, 1688, 1690, 1692, 1694, 1696, 1698,
     1700, 1702, 1704, 1706, 1708, 1710, 1712, 1714, 1716, 1718,
     1720, 1722, 1724, 1726, 1728, 1730, 1732, 1734, 1736, 1738,
     1740, 1742, 1744, 1746, 1748, 1750, 1752, 1754, 1756, 1758,
     1760, 1762, 1764, 1766, 1768, 1770, 1772, 1774, 1776, 1778,
     1780, 1782, 1784, 1786, 1788, 1790, 1792, 1794, 1796, 1798,
     1800, 1802, 1804, 1806, 1808, 1810, 1812, 1814, 1816, 1818,
     1820, 1822, 1824, 1826, 1828, 1830, 1832, 1834, 1836, 1838,
     1840, 1842, 1844, 1846, 1848, 1850, 1852, 1854, 1856, 1858,
     1860, 1862, 1864, 1866, 1868, 1870, 1872, 1874, 1876, 1878,
     1880, 1882, 1884, 1886, 1888, 1890, 1892, 1894, 1896, 1898,
     1900, 1902, 1904, 1906, 1908, 1910, 1912, 1914, 1916, 1918,
     1920, 1922, 1924, 1926, 1928, 1930, 1932, 1934, 1936, 1938,
     1940, 1942, 1944, 1946, 1948, 1950, 1952, 1954, 1956, 1958,
     1960, 1962, 1964, 1966, 1968, 1970, 1972, 1974, 1976, 1978,
     1980, 1982, 1984, 1986, 1988, 1990, 1992, 1994, 1996, 1998,
     2000, 2002, 2004, 2006, 2008, 2010, 2012, 2014, 2016, 2018,
     2020, 2022, 2024, 2026, 2028, 2030, 2032, 2034, 2036, 2038,
     2040, 2042, 2044, 2046,    1,    7,    1,    3,   41,   47,
       41,   43,   49,   55,   49,   51,   57,   63,   57,   59,
        1,    7,    1,    3,    9,   15,    9,   11,   17,   23,
       17,   19,   25,   31,   25,   27,  321,  327,  321,  323,
      361,  367,  361,  363,  369,  375,  369,  371,  377,  383,
      377,  379,  321,  327,  321,  323,  329,  335,  329,  331,
      337,  343,  337,  339,  345,  351,  345,  347,  385,  391,
      385,  387,  425,  431,  425,  427,  433,  439,  433,  435,
      441,  447,  441,  443,  385,  391,  385,  387,  393,  399,
      393,  395,  401,  407,  401,  403,  409,  415,  409,  411,
      449,  455,  449,  451,  489,  495,  489,  491,  497,  503,
      497,  499,  505,  511,  505,  507,  449,  455,  449,  451,
      457,  463,  457,  459,  465,  471,  465,  467,  473,  479,
      473,  475,    1,    7,    1,    3,   41,   47,   41,   43,
       49,   55,   49,   51,   57,   63,   57,   59,    1,    7,
        1,    3,    9,   15,    9,   11,   17,   23,   17,   19,
       25,   31,   25,   27,   65,   71,   65,   67,  105,  111,
      105,  107,  113,  119,  113,  115,  121,  127,  121,  123,
       65,   71,   65,   67,   73,   79,   73,   75,   81,   87,
       81,   83,   89,   95,   89,   91,  129,  135,  129,  131,
      169,  175,  169,  171,  177,  183,  177,  179,  185,  191,
      185,  187,  129,  135,  129,  131,  137,  143,  137,  139,
      145,  151,  145,  147,  153,  159,  153,  155,  193,  199,
      193,  195,  233,  239,  233,  235,  241,  247,  241,  243,
      249,  255,  249,  251,  193,  199,  193,  195,  201,  207,
      201,  203,  209,  215,  209,  211,  217,  223,  217,  219,
      513,  519,  513,  515,  553,  559,  553,  555,  561,  567,
      561,  563,  569,  575,  569,  571,  513,  519,  513,  515,
      521,  527,  521,  523,  529,  535,  529,  531,  537,  543,
      537,  539,  833,  839,  833,  835,  873,  879,  873,  875,
      881,  887,  881,  883,  889,  895,  889,  891,  833,  839,
      833,  835,  841,  847,  841,  843,  849,  855,  849,  851,
      857,  863,  857,  859,  897,  903,  897,  899,  937,  943,
      937,  939,  945,  951,  945,  947,  953,  959,  953,  955,
      897,  903,  897,  899,  905,  911,  905,  907,  913,  919,
      913,  915,  921,  927,  921,  923,  961,  967,  961,  963,
     1001, 1007, 1001, 1003, 1009, 1015, 1009, 1011, 1017, 1023,
     1017, 1019,  961,  967,  961,  963,  969,  975,  969,  971,
      977,  983,  977,  979,  985,  991,  985,  987,  513,  519,
      513,  515,  553,  559,  553,  555,  561,  567,  561,  563,
      569,  575,  569,  571,  513,  519,  513,  515,  521,  527,
      521,  523,  529,  535,  529,  531,  537,  543,  537,  539,
      577,  583,  577,  579,  617,  623,  617,  619,  625,  631,
      625,  627,  633,  639,  633,  635,  577,  583,  577,  579,
      585,  591,  585,  587,  593,  599,  593,  595,  601,  607,
      601,  603,  641,  647,  641,  643,  681,  687,  681,  683,
      689,  695,  689,  691,  697,  703,  697,  699,  641,  647,
      641,  643,  649,  655,  649,  651,  657,  663,  657,  659,
      665,  671,  665,  667,  705,  711,  705,  707,  745,  751,
      745,  747,  753,  759,  753,  755,  761,  767,  761,  763,
      705,  711,  705,  707,  713,  719,  713,  715,  721,  727,
      721,  723,  729,  735,  729,  731, 1025, 1031, 1025, 1027,
     1065, 1071, 1065, 1067, 1073, 1079, 1073, 1075, 1081, 1087,
     1081, 1083, 1025, 1031, 1025, 1027, 1033, 1039, 1033, 1035,
     1041, 1047, 1041, 1043, 1049, 1055, 1049, 1051, 1345, 1351,
     1345, 1347, 1385, 1391, 1385, 1387, 1393, 1399, 1393, 1395,
     1401, 1407, 1401, 1403, 1345, 1351, 1345, 1347, 1353, 1359,
     1353, 1355, 1361, 1367, 1361, 1363, 1369, 1375, 1369, 1371,
     1409, 1415, 1409, 1411, 1449, 1455, 1449, 1451, 1457, 1463,
     1457, 1459, 1465, 1471, 1465, 1467, 1409, 1415, 1409, 1411,
     1417, 1423, 1417, 1419, 1425, 1431, 1425, 1427, 1433, 1439,
     1433, 1435, 1473, 1479, 1473, 1475, 1513, 1519, 1513, 1515,
     1521, 1527, 1521, 1523, 1529, 1535, 1529, 1531, 1473, 1479,
     1473, 1475, 1481, 1487, 1481, 1483, 1489, 1495, 1489, 1491,
     1497, 1503, 1497, 1499, 1025, 1031, 1025, 1027, 1065, 1071,
     1065, 1067, 1073, 1079, 1073, 1075, 1081, 1087, 1081, 1083,
     1025, 1031, 1025, 1027, 1033, 1039, 1033, 1035, 1041, 1047,
     1041, 1043, 1049, 1055, 1049, 1051, 1089, 1095, 1089, 1091,
     1129, 1135, 1129, 1131, 1137, 1143, 1137, 1139, 1145, 1151,
     1145, 1147, 1089, 1095, 1089, 1091, 1097, 1103, 1097, 1099,
     1105, 1111, 1105, 1107, 1113, 1119, 1113, 1115, 1153, 1159,
     1153, 1155, 1193, 1199, 1193, 1195, 1201, 1207, 1201, 1203,
     1209, 1215, 1209, 1211, 1153, 1159, 1153, 1155, 1161, 1167,
     1161, 1163, 1169, 1175, 1169, 1171, 1177, 1183, 1177, 1179,
     1217, 1223, 1217, 1219, 1257, 1263, 1257, 1259, 1265, 1271,
     1265, 1267, 1273, 1279, 1273, 1275, 1217, 1223, 1217, 1219,
     1225, 1231, 1225, 1227, 1233, 1239, 1233, 1235, 1241, 1247,
     1241, 1243, 1537, 1543, 1537, 1539, 1577, 1583, 1577, 1579,
     1585, 1591, 1585, 1587, 1593, 1599, 1593, 1595, 1537, 1543,
     1537, 1539, 1545, 1551, 1545, 1547, 1553, 1559, 1553, 1555,
     1561, 1567, 1561, 1563, 1857, 1863, 1857, 1859, 1897, 1903,
     1897, 1899, 1905, 1911, 1905, 1907, 1913, 1919, 1913, 1915,
     1857, 1863, 1857, 1859, 1865, 1871, 1865, 1867, 1873, 1879,
     1873, 1875, 1881, 1887, 1881, 1883, 1921, 1927, 1921, 1923,
     1961, 1967, 1961, 1963, 1969, 1975, 1969, 1971, 1977, 1983,
     1977, 1979, 1921, 1927, 1921, 1923, 1929, 1935, 1929, 1931,
     1937, 1943, 1937, 1939, 1945, 1951, 1945, 1947, 1985, 1991,
     1985, 1987, 2025, 2031, 2025, 2027, 2033, 2039, 2033, 2035,
     2041, 2047, 2041, 2043, 1985, 1991, 1985, 1987, 1993, 1999,
     1993, 1995, 2001, 2007, 2001, 2003, 2009, 2015, 2009, 2011,
     1537, 1543, 1537, 1539, 1577, 1583, 1577, 1579, 1585, 1591,
     1585, 1587, 1593, 1599, 1593, 1595, 1537, 1543, 1537, 1539,
     1545, 1551, 1545, 1547, 1553, 1559, 1553, 1555, 1561, 1567,
     1561, 1563, 1601, 1607, 1601, 1603, 1641, 1647, 1641, 1643,
     1649, 1655, 1649, 1651, 1657, 1663, 1657, 1659, 1601, 1607,
     1601, 1603, 1609, 1615, 1609, 1611, 1617, 1623, 1617, 1619,
     1625, 1631, 1625, 1627, 1665, 1671, 1665, 1667, 1705, 1711,
     1705, 1707, 1713, 1719, 1713, 1715, 1721, 1727, 1721, 1723,
     1665, 1671, 1665, 1667, 1673, 1679, 1673, 1675, 1681, 1687,
     1681, 1683, 1689, 1695, 1689, 1691, 1729, 1735, 1729, 1731,
     1769, 1775, 1769, 1771, 1777, 1783, 1777, 1779, 1785, 1791,
     1785, 1787, 1729, 1735, 1729, 1731, 1737, 1743, 1737, 1739,
     1745, 1751, 1745, 1747, 1753, 1759, 1753, 1755};

// function prototypes
LOCO_PRIVATE void loco_compress_segment_8bit(LocoCompressState * state,
        I32 seg, I32 xstart, I32 xend, I32 ystart, I32 yend);
LOCO_PRIVATE void loco_compress_segment_12bit(LocoCompressState * state,
        I32 seg, I32 xstart, I32 xend, I32 ystart, I32 yend);
LOCO_PRIVATE void loco_write_integer(LocoCompressState * state, I32 val, I32 bits);

// functions

// clear result, except for buffer details
LOCO_PRIVATE void loco_clear_result(LocoCompressedImage *result)
{
    LOCO_ASSERT(result != NULL);
    // Clear result
    result->compressed_size_bytes = 0;
    result->segments.n_segs = 0;
    for (I32 seg = 0; seg<LOCO_MAX_SEGS; seg++) {
        result->segments.seg_ptr[seg] = NULL;
        result->segments.n_bits[seg] = 0;
    }
    result->segments.seg_ptr[LOCO_MAX_SEGS] = NULL;
}

I32 loco_compress(
    LocoCompressState *state,
    const LocoImage   *image,
    LocoCompressedImage *result)
{
    LOCO_ASSERT(state != NULL);
    LOCO_ASSERT(image != NULL);
    LOCO_ASSERT(image->data != NULL);
    LOCO_ASSERT(result != NULL);
    LOCO_ASSERT(result->data != NULL);
    loco_clear_result(result);

    /* Copy some parameters to equivalent globals */
    state->image_width = image->width;
    state->image_height = image->height;
    state->n_segs = image->n_segs;

    U32 endian = 1;
    state->is_little_endian = *((U8*)(&endian));

    I32 status = loco_check_image(image); // Check validity of image data
    if (status & LOCO_ABORT_COMPRESSION_FLAG) {
        LOCO_WARN7(LOCO_COMPRESS_ABORT,
                "In loco_compress(), check_image() status 0x04%x "
                "indicates compression cannot continue. "
                "Image width: %d, space_width: %d, height:%d, n_segs: %d, "
                "bitdepth: %d, size_data_bytes: %d.",
                (U32)status, image->width, image->space_width, image->height,
                image->n_segs, image->bit_depth, image->size_data_bytes);
        return status;
    }

    /* Setup pointers to the rows of the image_old */
    for(I32 y=0; y<image->height; y++) {
        state->image_rows[y] = image->data + y*image->space_width;
    }

    /* Compute error containment segment rectangles */
    loco_setup_segs(state->image_width, state->image_height, state->n_segs,
            state->seg_bound);

    /* Setup output bitstream pointers */
    state->p_out = result->data;
    I32 result_buf_size_local = result->size_data_bytes;
    if (result_buf_size_local < 0) {
        result_buf_size_local = 0;
    }
    LOCO_COMPILE_ASSERT(sizeof(LocoBitstreamType) != 0, loco_bitstream_zero);
    state->p_stop = result->data + result_buf_size_local/sizeof(LocoBitstreamType);
    result->segments.seg_ptr[0] = (U8*)result->data;

    // Compress the segments
    for (I32 seg=0; seg<state->n_segs; seg++) {
        /* Reset bitstream output word */
        state->bit_count = 8*sizeof(LocoBitstreamType)-1;
        state->out_word = 0;

        /* Compress the segment */
        LOCO_ASSERT_1(image->bit_depth > 0 && image->bit_depth <= BITDEPTH_12BIT,
                image->bit_depth);
        if (image->bit_depth <= BITDEPTH_8BIT) {
            loco_compress_segment_8bit(state, seg, state->seg_bound[seg].xstart,
                    state->seg_bound[seg].xend, state->seg_bound[seg].ystart,
                    state->seg_bound[seg].yend);
        } else {
            loco_compress_segment_12bit(state, seg, state->seg_bound[seg].xstart,
                    state->seg_bound[seg].xend, state->seg_bound[seg].ystart,
                    state->seg_bound[seg].yend);
        }

        /* Store last word (if necessary) and record position of end of segment */
        if (state->bit_count < (I32)(8*sizeof(LocoBitstreamType)-1)
                && state->p_out < state->p_stop) {
            *state->p_out++ = FIX_WORD(state->out_word, state->is_little_endian);
        }
        result->segments.seg_ptr[seg+1] = (U8*)state->p_out;
        result->segments.n_bits[seg] =
                8 * (I32) (result->segments.seg_ptr[seg + 1]
                           - result->segments.seg_ptr[seg]);
    }
    result->segments.n_segs = state->n_segs;
    result->compressed_size_bytes = (I32) (result->segments.seg_ptr[result->segments.n_segs]
               - result->segments.seg_ptr[0]);

    /* Check if the output buffer filled up, and return */
    if (state->p_out == state->p_stop) {
        status |= LOCO_BUFFER_FILLED_FLAG;
    }
    return status;
}

// Check if an image is valid for compression
I32 loco_check_image(const LocoImage *image)
{
    I32 status = 0;

    LOCO_ASSERT(image != NULL);

    /* Check that image dimensions are not too large */
    if (image->width > LOCO_MAX_IMAGE_WIDTH) {
        status |= LOCO_BIG_WIDTH_FLAG | LOCO_ABORT_COMPRESSION_FLAG;
    }
    if (image->height > LOCO_MAX_IMAGE_HEIGHT) {
        status |= LOCO_BIG_HEIGHT_FLAG | LOCO_ABORT_COMPRESSION_FLAG;
    }

    /* Check that image_width is compatible with image_space_width */
    if (image->width > image->space_width) {
        status |= LOCO_BAD_SPACE_WIDTH_FLAG | LOCO_ABORT_COMPRESSION_FLAG;
    }

    /* Check that image dimensions are not too small */
    if (image->width < LOCO_MIN_IMAGE_WIDTH) {
        status |= LOCO_SMALL_WIDTH_FLAG | LOCO_ABORT_COMPRESSION_FLAG;
    }
    if (image->height < LOCO_MIN_IMAGE_HEIGHT) {
        status |= LOCO_SMALL_HEIGHT_FLAG | LOCO_ABORT_COMPRESSION_FLAG;
    }

    /* Check that the average number of pixels per segment is not too small */
    if (image->width*image->height < image->n_segs*LOCO_MIN_SEGMENT_PIXELS) {
        status |= LOCO_SMALL_IMAGE_FLAG | LOCO_ABORT_COMPRESSION_FLAG;
    }

    /* Check that the number of segments is in the proper range */
    if (image->n_segs < 1 || image->n_segs > LOCO_MAX_SEGS) {
        status |= LOCO_BAD_N_SEGS_FLAG | LOCO_ABORT_COMPRESSION_FLAG;
    }

    // Check bit width is acceptable
    if (image->bit_depth < 0 || image->bit_depth > BITDEPTH_12BIT) {
        status |= LOCO_BAD_BIT_DEPTH_FLAG | LOCO_ABORT_COMPRESSION_FLAG;
    }

    // Check image size is at least space width * height * size(LocoPixelType)
    if(image->space_width*image->height*sizeof(LocoPixelType) > image->size_data_bytes){
        status |= LOCO_SMALL_BUFFER_FLAG | LOCO_ABORT_COMPRESSION_FLAG;
    }

    return status;
}

LOCO_PRIVATE void loco_compress_segment_8bit(LocoCompressState * state,
        I32 seg, I32 xstart, I32 xend,
        I32 ystart, I32 yend)
{
    LOCO_ASSERT(state != NULL);

    I32 est;
    I32 residual;
    I32 msum;
    I32 sum;
    I32 kshift;
    I32 context;
    I32 context_info;
    I32 b = 0;
    I32 c = 0;
    I32 a = 0;
    I32 d = 0;
    I32 e = 0;
    I32 ctxt2s = 0;
    I32 ctxt1s = 0;
    I32 loop_cnt;
    I32 loop_limit;
    LocoPixelType *p_line_start;
    LocoPixelType *p_line_start_p1;
    LocoPixelType *p_line_end;
    LocoPixelType *p_pixel;
    LocoPixelType *p_pixel_m1 = NULL;

    // Initialize context statistics
    for (I32 i=0;i<LOCO_NCONTEXTS;i++) {
        state->c_count[i] = INITCC_8BIT;
        state->c_mag_sum[i] = INITCMS_8BIT;
        state->c_sum[i] = 0;
        state->c_bias[i] = 0;
    }

    // Write segment header
    loco_write_integer(state, HEADER_CODE_FOR_8BIT, HEADER_CODE_BITS);
    loco_write_integer(state, state->image_width-1, IMAGEWIDTH_BITS);
    loco_write_integer(state, state->image_height-1, IMAGEHEIGHT_BITS);
    loco_write_integer(state, state->n_segs-1, SEGINDEX_BITS);
    loco_write_integer(state, seg, SEGINDEX_BITS);

    LOCO_ASSERT_2(ystart < LOCO_MAX_IMAGE_HEIGHT - 1,
            ystart, LOCO_MAX_IMAGE_HEIGHT);

    // Write first two pixels directly
    loco_write_integer(state, state->image_rows[ystart][xstart],   BITDEPTH_8BIT);
    loco_write_integer(state, state->image_rows[ystart][xstart+1], BITDEPTH_8BIT);

    // Main encoding loop
    for (I32 y=ystart; y<yend; y++) {
        p_line_start = state->image_rows[y] + xstart;
        p_line_start_p1 = p_line_start + 1;
        p_line_end = state->image_rows[y] + xend-1;
        p_pixel = p_line_start;
        if (y==ystart) {
            e = *p_pixel++;
            b = *p_pixel++;
        } else {
            p_pixel_m1 = state->image_rows[y-1]+xstart;
            a = *p_pixel_m1++;
        }
        do {
            if (y==ystart) { // top row
                est = b;
                context_info = loco_context_info_table[GFOUR_TO_CTXT_8BIT(b - e)];
                context = (context_info>>1) | 0x90;
            } else if (p_pixel == p_line_start) { // left side
                d = *p_pixel_m1++;
                ctxt1s = G_TO_CTXT_8BIT(d - a);
                est = a;
                context_info = loco_context_info_table[ctxt1s];
                context = (context_info>>1) | 0x12;
            } else {
                if (a > b) {
                    if (c >= a) {
                        est = b;
                    } else if (c <= b) {
                        est = a;
                    } else {
                        est = a + b - c;
                    }
                } else {
                    if (c >= b) {
                        est = a;
                    } else if (c <= a) {
                        est = b;
                    } else {
                        est = a + b - c;
                    }
                }
                if (p_pixel == p_line_start_p1) { // left side + 1
                    d = *p_pixel_m1++;
                    ctxt1s = G_TO_CTXT_8BIT(d - a);
                    context_info = loco_context_info_table[(G_TO_CTXT_8BIT(c - b)>>3) |
                                                       ctxt1s | ctxt2s];
                    context = (context_info>>1) | 0x02;
                } else if (p_pixel == p_line_end) { // bottom row
                    context_info = loco_context_info_table[GFOUR_TO_CTXT_8BIT(b - e) |
                                       (G_TO_CTXT_8BIT(c - b)>>3) | ctxt2s];
                    context = (context_info>>1) | 0x80;
                } else {
                    d = *p_pixel_m1++;
                    ctxt1s = G_TO_CTXT_8BIT(d - a);
                    context_info = loco_context_info_table[GFOUR_TO_CTXT_8BIT(b - e) |
                               (G_TO_CTXT_8BIT(c - b)>>3) | ctxt1s | ctxt2s];
                    context = context_info>>1;
                }
            }

            ctxt2s = ctxt1s<<3;
            e = b;
            b = *p_pixel++;
            c = a;
            a = d;

            /* Incorporate the context-based bias into the pixel estimate
               and compute the residual */
            if (context_info & 01) {
                est -= state->c_bias[context];
                /* Clip estimate to allowed range */
                if (est & OUT_OF_RANGE_MASK_8BIT) {
                    if (est < 0) {
                        est = 0;
                    }
                    else {
                        est = PMAX_8BIT;
                    }
                }
                residual = est - b;
            } else {
                est += state->c_bias[context];
                /* Clip estimate to allowed range */
                if (est & OUT_OF_RANGE_MASK_8BIT) {
                    if (est < 0) {
                        est = 0;
                    }
                    else {
                        est = PMAX_8BIT;
                    }
                }
                residual = b - est;
            }

            /* Remap residual.  This remapping is guaranteed to be
               invertible if the image pixel values are all in the proper range;
               otherwise, it might not be. */
            residual &= PIXEL_MASK_8BIT;
            residual = (residual ^ RESIDUAL_SIGN_BIT_8BIT) - RESIDUAL_SIGN_BIT_8BIT;

            /* Retrieve count and magnitude sum for the context.  A mask is
               applied to the magnitude sum as a precaution, ensuring that
               the computation of k goes smoothly.  */
            kshift = state->c_count[context]++;
            msum = state->c_mag_sum[context] & MSUM_MASK;

            sum = state->c_sum[context] + residual;
            if (sum > 0) {
                state->c_bias[context]++;
                sum -= (kshift + 1);
            } else if (sum < -(kshift+1)) {
                state->c_bias[context]--;
                sum += (kshift + 1);
            } else {
                // no adjustment
            }

            /* Update msum, and remap residual to a nonnegative integer */
            if (residual < 0) {
                state->c_mag_sum[context] -= residual;
                residual = ~(residual << 1);
            } else {
                state->c_mag_sum[context] += residual;
                residual <<= 1;
            }

            /* Normalize sums if necessary */
            if (kshift==MAXN_8BIT-1) {
                state->c_count[context] >>= 1;
                state->c_mag_sum[context] >>= 1;
                sum >>= 1;  /* NOTE: sign extension required (may not be portable) */
            }
            state->c_sum[context] = sum;

            // Write the "uncoded" portion of the residual
            loop_limit = 8*sizeof(I32);
            for (loop_cnt = 0; kshift<=msum && loop_cnt < loop_limit; loop_cnt++) {
                WRITE_BIT(residual & 01);
                residual >>= 1;
                kshift <<= 1;
            }
            LOCO_ASSERT_2(loop_cnt < loop_limit, loop_cnt, loop_limit);

            /* Unary Encode the rest of the residual */
            state->bit_count -= residual;
            while (state->bit_count < 0) {
                if (state->p_out < state->p_stop) {
                    *state->p_out++ = FIX_WORD(state->out_word, state->is_little_endian);
                }
                state->out_word = 0;
                state->bit_count += 8*sizeof(LocoBitstreamType);
            }
            WRITE_BIT(1);

        } while (p_pixel <= p_line_end);

    }
}

LOCO_PRIVATE void loco_compress_segment_12bit(LocoCompressState * state,
        I32 seg, I32 xstart, I32 xend,
        I32 ystart, I32 yend)
{
    LOCO_ASSERT(state != NULL);

    I32 est;
    I32 residual;
    I32 msum;
    I32 sum;
    I32 kshift;
    I32 context;
    I32 context_info;
    I32 b = 0;
    I32 c = 0;
    I32 a = 0;
    I32 d = 0;
    I32 e = 0;
    I32 ctxt2s = 0;
    I32 ctxt1s = 0;
    I32 loop_cnt;
    I32 loop_limit;
    LocoPixelType *p_line_start;
    LocoPixelType *p_line_start_p1;
    LocoPixelType *p_line_end;
    LocoPixelType *p_pixel;
    LocoPixelType *p_pixel_m1 = NULL;

    // Initialize context statistics
    for (I32 i=0;i<LOCO_NCONTEXTS;i++) {
        state->c_count[i] = INITCC_12BIT;
        state->c_mag_sum[i] = INITCMS_12BIT;
        state->c_sum[i] = 0;
        state->c_bias[i] = 0;
    }

    // Write segment header
    loco_write_integer(state, HEADER_CODE_FOR_12BIT, HEADER_CODE_BITS);
    loco_write_integer(state, state->image_width-1, IMAGEWIDTH_BITS);
    loco_write_integer(state, state->image_height-1, IMAGEHEIGHT_BITS);
    loco_write_integer(state, state->n_segs-1, SEGINDEX_BITS);
    loco_write_integer(state, seg, SEGINDEX_BITS);

    LOCO_ASSERT_2(ystart < LOCO_MAX_IMAGE_HEIGHT-1,
            ystart, LOCO_MAX_IMAGE_HEIGHT);

    // Write first two pixels directly
    loco_write_integer(state, state->image_rows[ystart][xstart], BITDEPTH_12BIT);
    loco_write_integer(state, state->image_rows[ystart][xstart+1], BITDEPTH_12BIT);

    // Main encoding loop
    for (I32 y=ystart; y<yend; y++) {
        p_line_start = state->image_rows[y] + xstart;
        p_line_start_p1 = p_line_start + 1;
        p_line_end = state->image_rows[y] + xend-1;
        p_pixel = p_line_start;
        if (y==ystart) {
            e = *p_pixel++;
            b = *p_pixel++;
        } else {
            p_pixel_m1 = state->image_rows[y-1]+xstart;
            a = *p_pixel_m1++;
        }
        do {
            if (y==ystart) { // top row
                est = b;
                context_info = loco_context_info_table[GFOUR_TO_CTXT_12BIT(b - e)];
                context = (context_info>>1) | 0x90;
            } else if (p_pixel == p_line_start) { // left side
                d = *p_pixel_m1++;
                ctxt1s = G_TO_CTXT_12BIT(d - a);
                est = a;
                context_info = loco_context_info_table[ctxt1s];
                context = (context_info>>1) | 0x12;
            } else {
                if (a > b) {
                    if (c >= a) {
                        est = b;
                    } else if (c <= b) {
                        est = a;
                    } else {
                        est = a + b - c;
                    }
                } else {
                    if (c >= b) {
                        est = a;
                    } else if (c <= a) {
                        est = b;
                    } else {
                        est = a + b - c;
                    }
                }
                if (p_pixel == p_line_start_p1) { // left side + 1
                    d = *p_pixel_m1++;
                    ctxt1s = G_TO_CTXT_12BIT(d - a);
                    context_info = loco_context_info_table[(G_TO_CTXT_12BIT(c - b)>>3) |
                                                       ctxt1s | ctxt2s];
                    context = (context_info>>1) | 0x02;
                } else if (p_pixel == p_line_end) { // bottom row
                    context_info = loco_context_info_table[GFOUR_TO_CTXT_12BIT(b - e) |
                                       (G_TO_CTXT_12BIT(c - b)>>3) | ctxt2s];
                    context = (context_info>>1) | 0x80;
                } else {
                    d = *p_pixel_m1++;
                    ctxt1s = G_TO_CTXT_12BIT(d - a);
                    context_info = loco_context_info_table[GFOUR_TO_CTXT_12BIT(b - e) |
                               (G_TO_CTXT_12BIT(c - b)>>3) | ctxt1s | ctxt2s];
                    context = context_info>>1;
                }
            }

            ctxt2s = ctxt1s<<3;
            e = b;
            b = *p_pixel++;
            c = a;
            a = d;

            /* Incorporate the context-based bias into the pixel estimate
               and compute the residual */
            if (context_info & 01) {
                est -= state->c_bias[context];
                /* Clip estimate to allowed range */
                if (est & OUT_OF_RANGE_MASK_12BIT) {
                    if (est < 0) {
                        est = 0;
                    }
                    else {
                        est = PMAX_12BIT;
                    }
                }
                residual = est - b;
            } else {
                est += state->c_bias[context];
                /* Clip estimate to allowed range */
                if (est & OUT_OF_RANGE_MASK_12BIT) {
                    if (est < 0) {
                        est = 0;
                    }
                    else {
                        est = PMAX_12BIT;
                    }
                }
                residual = b - est;
            }

            /* Remap residual.  This remapping is guaranteed to be
               invertible if the image pixel values are all in the proper range;
               otherwise, it might not be. */
            residual &= PIXEL_MASK_12BIT;
            residual = (residual ^ RESIDUAL_SIGN_BIT_12BIT) - RESIDUAL_SIGN_BIT_12BIT;

            /* Retrieve count and magnitude sum for the context.  A mask is
               applied to the magnitude sum as a precaution, ensuring that
               the computation of k goes smoothly.  */
            kshift = state->c_count[context]++;
            msum = state->c_mag_sum[context] & MSUM_MASK;

            sum = state->c_sum[context] + residual;
            if (sum > 0) {
                state->c_bias[context]++;
                sum -= (kshift + 1);
            } else if (sum < -(kshift + 1)) {
                state->c_bias[context]--;
                sum += (kshift + 1);
            } else {
                // no adjustments
            }

            /* Update msum, and remap residual to a nonnegative integer */
            if (residual < 0) {
                state->c_mag_sum[context] -= residual;
                residual = ~(residual << 1);
            } else {
                state->c_mag_sum[context] += residual;
                residual <<= 1;
            }

            /* Store updated context information */
            if (kshift == MAXN_12BIT-1) {   /* Normalize sums if necessary */
                state->c_count[context] >>= 1;
                state->c_mag_sum[context] >>= 1;
                sum >>= 1;  /* NOTE: sign extension required (may not be portable) */
            }
            state->c_sum[context] = sum;

            /* Write the "uncoded" portion of the residual */
            loop_limit = 8*sizeof(I32);
            for (loop_cnt = 0; kshift<=msum && loop_cnt < loop_limit; loop_cnt++) {
                WRITE_BIT(residual & 01);
                residual >>= 1;
                kshift <<= 1;
            }
            LOCO_ASSERT_2(loop_cnt < loop_limit, loop_cnt, loop_limit);

            /* Unary Encode the rest of the residual */
            state->bit_count -= residual;
            while (state->bit_count < 0) {
                if (state->p_out < state->p_stop) {
                    *state->p_out++ = FIX_WORD(state->out_word, state->is_little_endian);
                }
                state->out_word = 0;
                state->bit_count += 8*sizeof(LocoBitstreamType);
            }
            WRITE_BIT(1);

        } while (p_pixel <= p_line_end);

    }
}

LOCO_PRIVATE void loco_write_integer(
        LocoCompressState * state, I32 val, I32 bits)
{
    LOCO_ASSERT(state != NULL);
    for (I32 bits_local = bits; bits_local > 0; bits_local--) {
        WRITE_BIT(val & 01);
        val >>= 1;
    }
}
